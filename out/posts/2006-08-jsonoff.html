<!DOCTYPE html>
<html>
<head>
    <title>разные стили при js on/off</title>
    <meta name="generator" content="DocPad v6.59.6" />
    <style >html.wait {
	cursor: wait !important;
	opacity: 0;
	transition: opacity 0.5s ease;
}</style><link  rel="stylesheet" href="/styles/style.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="alternate" type="application/atom+xml" title="Vitaly Sharovato" href="/atom.xml">
</head>
<body>
    <h1>разные стили при js on/off</h1>
<div><p>Часто на сайтах некий функционал реализован целиком на js. Всё бы хорошо, но некоторые несознательные граждане отключают выполнение javascript в браузере, тем самым выключая весь этот замечательный функционал :). И остаются потом пустые контролы, нефункционирующие кнопки и прочая прочая. Поэтому всё сознательное человечество пользователям с выключенным js не показывает элементы, которые без js бессмысленны. Раньше это делалось двумя вариантами
(с небольшими вариациями):</p>
<ol>
<li><p>генерируя зависящее от js содержимое в самом js, соответственно человек без js и не получит этого содержимого</p>
</li>
<li><p>скрывая в css содержимое, которое зависит от js, а потом по window.onload делать это содержимое видимым.</p>
</li>
</ol>
<p>На самом деле, второй вариант в самом оптимальном виде выглядел так: в css прописывалось по умолчанию &quot;сокрытие&quot; содержимого <var>display:none</var> или ещё как и писался селектор навроде #js_enabled, в правилах которого это самое содержимое делалось <var>display: block</var>, и по <var>window.onload</var> к body применялся этот самый id <var>js_enabled</var>. </p>
<p>Выходило дёшево и сердито - по умолчанию всё скрыто, после загрузки документа js (буде таковой включен), делал всё видимым.</p>
<p>Оба метода далеки от идеальности по многим причинам. И одна из главных проблем - необходимость дожидаться полной загрузки документа - там может быть множество замещаемых элементов (например, <var>img</var>), полной загрузки которых будет ждать <var>window.onload</var>.</p>
<p>Да, проблему ожидания загрузки замещаемых элементов событием <var>window.onload</var>
можно решить, но остаётся ещё много проблем, например, занятость id/className-атрибутов у body, но это не решает самой главной проблемы существующих методов - увеличения связности компонентов документа. Порой сидишь и рисуешь связи между css/js/особенностями браузеров/серверным кодом, чтобы понять, откуда то или иное вылазит.</p>
<p>Я же предлагаю совершенно новый метод (во всяком случае, я долго искал и не нашёл ни одного похожего применения).</p>
<p>Как я уже говорил, несмотря на то, что псевдопротокол <var>javascript:</var> не описан в стандартах, он функционирует во всех браузерах. Возвращённое после выполнения js-кода значение и будет являться содержимым &quot;документа&quot;. Для иллюстрации предлагаю описать в html ссылку вида</p>
<pre><code>&lt;a href=&quot;javascript:&#39;new content&#39;&quot;&gt;link&lt;/a&gt;
</code></pre><p>и нажать на неё. Как я уже упоминал в статье про события, браузер выполнит &quot;переход&quot; на &quot;страницу&quot;, содержимое которой будет определено возвращённым значением.</p>
<p>На этом и основан мой метод. Предположим, что у нас есть блок <var>#js_control</var>, который целиком и полностью зависит от js, и без js не нужный.</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;title&gt;test.&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
    /*в этой таблице стилей описывается вид страницы без js */
    #js_control { display: none; }
&lt;/style&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;javascript:&#39;
    /*вид страницы с js*/
    #js_control { display: block; }
&#39;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;js_control&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;apply rule&quot; /&gt;
    &lt;input type=&quot;submit&quot; onclick=&quot;someFunction()&quot; /&gt;
    &lt;/div&gt;
    &lt;p&gt;text&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>В общем, получается, что в обычной таблице стилей мы описываем &quot;умолчальное&quot; состояние страницы, во второй, <em>необычной</em> таблице стилей описываем css, который будет применён при включенном js. Необычна она тем, что css-код, который я в ней написал, является строкой. Когда браузер запросит таблицу стилей по её href&#39;у, он выполнит javascript-код, который, в свою очередь вернёт строку, в которой я описал css-код. Браузер применит этот css-код к документу.</p>
<p>Таким образом, очень удобно происходит &quot;разделение&quot; - если js выключен, вторая таблица стилей не применится.</p>
<p>Браузеры, в которых я это проверял: IE4/5/5.5/6/7b3, Opera5/8/9, FF1/1.5.</p>
<p>Кстати, только что проверил, opera8/8.5/9, FF1.5, IE4/5/5.5/6 - можно подключать и внешние таблицы стилей:</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;javascript:&#39;@import url(http://host.com/js-enabled.css);&#39;&quot; /&gt;
</code></pre><p>К сожалению, IE4 и FF не понимают иной нотации, кроме <var>@import url(someurl)</var>, причём если написать в кавычках, FF начинает кидаться эксепшнами странными, даже если всё нормально сэкранировать. Если же писать относительный урл, то опять же FF не подгружает почему-то, но как мне кажется, это всё настолько недокументировано, что можно простить странное поведение :)</p>
<p>В общем, получается такая ситуация: если правил немного и в них мало что нужно экранировать (да-да, весь css-код в этом случае суть строка), например, если мало правил с <var>content</var>, то удобнее прописать правила прямо в такой таблице стилей. Если же правил много или не хочется ничего экранировать, то проще написать последним методом, правда, придётся писать абсолютный адрес внешней таблицы стилей.</p>
</div>
    <script >(function(){
	/* Did we just livereload? */
var log = !!(localStorage && console && console.log && true);
if ( log && localStorage.getItem('/docpad-livereload/reloaded') === 'yes' ) {
	localStorage.removeItem('/docpad-livereload/reloaded');
	console.log('LiveReload completed at', new Date())
}

/* Listen for the regenerated event and perform a reload of the page when the event occurs */
var listen = function(){
	var primus = new Primus('/docpad-livereload');
	primus.on('data', function(data){
		if ( data && data.message ) {
			if ( data.message === 'generateBefore' ) {
				if ( log ) {
					console.log('LiveReload started at', new Date());
				}
				if ( typeof document.getElementsByTagName !== 'undefined' ) {
	document.getElementsByTagName('html')[0].className += ' wait';
}
			}
			else if ( data.message === 'generateAfter' ) {
				if ( log ) {
					localStorage.setItem('/docpad-livereload/reloaded', 'yes');
				}
				document.location.reload();
			}
		}
	});
};
	/* Inject socket into our page */
var inject = function(){
	var t = document.createElement('script');
	t.type = 'text/javascript';
	t.async = 'async';
	t.src = '/primus/primus.js';
	t.onload = listen;
	var s = document.getElementsByTagName('script')[0];
	s.parentNode.insertBefore(t, s);
};
	if ( typeof Primus !== 'undefined' ) {
		listen();
	} else {
		inject();
	}
})();</script>
    <div class="comments"></div>
</body>
</html>